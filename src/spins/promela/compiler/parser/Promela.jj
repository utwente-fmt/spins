// Copyright 2010, University of Twente, Formal Methods and Tools group
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

options {
  JDK_VERSION = "1.5";
  STATIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
}

PARSER_BEGIN(Promela)
package spins.promela.compiler.parser;

import spins.promela.compiler.*;
import spins.promela.compiler.automaton.*;
import spins.promela.compiler.expression.*;
import spins.promela.compiler.variable.*;
import spins.promela.compiler.actions.*;
import java.io.*;
import java.util.*;
import static spins.promela.compiler.ltsmin.util.LTSminUtil.*;
import spins.promela.compiler.ltsmin.util.LTSminUtil;
import static spins.promela.compiler.parser.PromelaConstants.*;

public class Promela {
	public static final String C_STATE_PROC_COUNTER = "_pc";
	public static final String C_STATE_PID = "_pid";
	
	public static final VariableType C_TYPE_PROC_COUNTER 	= VariableType.PC;
	public static final VariableType C_TYPE_PID 			= VariableType.PID;

	/** Copy Constructors */
    public Promela(Promela prom, PromelaTokenManager tm) {
        this(tm);
        copy(this, prom);
    }

    public Promela(Specification spec, java.io.InputStream stream) {
        this(stream);
        specification = spec;
    }

	public Promela(Promela prom, java.io.InputStream stream) {
	    this(stream);
	    copy(this, prom);
	}

    private void copy(Promela dst, Promela src) {
        dst.currentProc = src.currentProc;
        dst.specification = src.specification;
        dst.automaton = src.automaton;
        dst.procNr = src.procNr;
        dst.labels = src.labels;
        dst.gotos = src.gotos;
        dst.type = src.type;
    }

	private Specification specification;
	private Proctype currentProc;
	private Automaton automaton;
	private int procNr = 0;
	private int unlessPriority = 0;
	private VariableType type;
	private boolean declarations;

	private Map<String, State> labels = new HashMap<String, State>();

	private Map<State, Token> gotos = new HashMap<State, Token>();
	
	public int getNextProcNr(int nrActive) {
		return procNr++;
	}

	private void setGotos() throws ParseException {
		for(State n : gotos.keySet()) {
			Token t = gotos.get(n);
			State ref = labels.get(t.image);
			if(ref == null) {
				throw new MyParseException("Could not find label: " + t.image, t);
			}
			new GotoTransition(n, ref, t.image);
		}
		gotos.clear();
		labels.clear();
	}

	public void addPID(Proctype p) {
		Variable pid = new Variable(C_TYPE_PID, C_STATE_PID, -1, p);
		p.addVariable(pid, false);
	}

	public void addPC(Proctype p) {
		Variable pc = new Variable(C_TYPE_PROC_COUNTER, C_STATE_PROC_COUNTER, -1, p);
		int initial_pc = (p.getNrActive() == 0 && !p.getName().equals("never") ? -1 : 0);
		try { pc.setInitExpr(new ConstantExpression(new Token(NUMBER, ""+initial_pc), initial_pc));
		} catch (ParseException e) { assert (false); }
		p.addVariable(pc, false);
	}

    Expression varref() throws ParseException { return varref(null); }
}
PARSER_END(Promela)

TOKEN : {	/* Keywords */
	<PROCTYPE: "proctype">
|	<INIT: "init">
|	<NEVER: "never">
|	<TRACE: "trace">
|	<NOTRACE: "notrace">
|	<TYPEDEF: "typedef">
|	<MTYPE: "mtype">
|	<BIT: "bit">
|	<BOOL: "bool">
|	<BYTE: "byte">
|	<PID: "pid">
|	<SHORT: "short">
|	<INT: "int">
|	<CHAN: "chan">
/*|	<ACTIVE: "active">*/
|	<PRIORITY: "priority">
|	<PROVIDED: "provided">
|	<HIDDEN: "hidden">
|	<SHOW: "show">
|	<XR: "xr">
|	<XS: "xs">
|	<OF: "of">
|	<EVAL: "eval">
|   <FOR: "for">
|	<IF: "if">
|	<FI: "fi">
|	<DO: "do">
|	<OD: "od">
|	<ATOMIC: "atomic">
|	<D_STEP: "d_step">
|	<ELSE: "else">
|	<BREAK: "break">
|	<GOTO: "goto">
|	<PRINT: "printf">
|	<ASSERT: "assert">
|	<LEN: "len">
|	<TIMEOUT: "timeout">
|	<NP_: "np_">
|	<ENABLED: "enabled">
|	<PC_VALUE: "pc_value">
|	<RUN: "run">
|	<FULL: "full">
|	<EMPTY: "empty">
|	<NFULL: "nfull">
|	<NEMPTY: "nempty">
|	<TRUE: "true">
|	<FALSE: "false">
|	<SKIP_: "skip">
|	<UNLESS: "unless">
|	<VAR_PID: "_pid">
|   <VAR_NR_PR: "_nr_pr">
}

TOKEN : {	/* Operators */
	<LCURLY: "{">
|	<RCURLY: "}">
|	<ASSIGN: "=">
|	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACK: "[">
|	<RBRACK: "]">
|	<OPTION: "::">
|	<COLON: ":">
|	<SEMICOLON: ";">
|	<COMMA: ",">
|	<RARROW: "->">
|	<CH_SEND_SORTED: "!!">
|	<CH_READ: "?">
|	<CH_READ_RAND: "??">
|	<AT: "@">
|	<BNOT: "~">
|	<LNOT: "!">
|	<MINUS: "-">
|	<TIMES: "*">
|	<DIVIDE: "/">
|	<MODULO: "%">
|	<PLUS: "+">
|	<LSHIFT: "<<">
|	<RSHIFT: ">>">
|	<LT: "<">
|	<LTE: "<=">
|	<GT: ">">
|	<GTE: ">=">
|	<EQ: "==">
|	<NEQ: "!=">
|	<BAND: "&">
|	<XOR: "^">
|	<BOR: "|">
|	<LAND: "&&">
|	<LOR: "||">
|	<INCR: "++">
|	<DECR: "--">
|	<DOT: ".">
}

/**
 * End of file may mean:
 * - End of input file, then we are done.
 * - End of virtual input (see ReInit) from preprocessor define,
 *   then we have to switch back to the previous stream (on preprocessing stack).
 * - End of preprocessor #if condition, then we terminate the parsing because a
 *   recursive parser was started (see PREPROCESSOR_IF, new Promela).
 * - Premature end of input if the preprocessor if stack is non-empty,
 *   erroneous input. 
 */
<*> TOKEN:
{
    < EOF >
    {
        if (!Preprocessor.preprocessing.empty()) {
            SimpleCharStream scs = Preprocessor.preprocessing.pop();
            Preprocessor.setFilename(Preprocessor.files.pop());
            if (null == scs) return; // #if, no need to restore, since a recursive parser was launched
            Preprocessor.DefineMapping current = Preprocessor.current.pop();
            if (null != current && current.size() > 0) {
                Preprocessor.removeDefines();
            }
            ReInit(scs);
            Token next = getNextToken();
            matchedToken.image = next.image;
            matchedToken.kind = next.kind;
            matchedToken.next = next.next;
            matchedToken.specialToken = next.specialToken;
        } else {
            if (!Preprocessor.ifs.empty()) {
                throw new AssertionError("Missing #endif");
            }
	        Preprocessor.DefineMapping current = Preprocessor.defines("__include_end");
	        if (null != current) { // Identifier is defined in preprocessor
	            // switch to a virtual stream and push the previous stream on a stack
	            ByteArrayInputStream is = new ByteArrayInputStream(current.defineText.getBytes());
	            ReInit(new SimpleCharStream(is, current.line, current.column));
	            // override TOKEN result with next token
	            Token next = getNextToken(); 
	            matchedToken.image = next.image;
	            matchedToken.kind = next.kind;
	            matchedToken.next = next.next;
	            matchedToken.specialToken = next.specialToken;
	            Preprocessor.removeDefine("__include_end");
	        }
        }
    }
}

SKIP : {
   	"inline" : PREPROCESSOR_INLINE
| 	"defined" : PREPROCESSOR_DEFINED
|   "ndef" : PREPROCESSOR_NDEFINED
}

<PREPROCESSOR_DEFINED> SKIP: // parse define name
{
    "("
    {
    	Preprocessor.level++;
    	image.setLength(0);
    } : PREPROCESSOR_DEFINED
|   " " : PREPROCESSOR_DEFINED
|   < ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        String defined = image.toString().trim();
		while (0 != Preprocessor.level) {
			Preprocessor.level--;
			if (RPAREN != getNextToken().kind)
				throw new AssertionError("Missing closing parenthesis after defined.");
		}
		// reinitialize input_stream
	    String newText = null != Preprocessor.defines(defined) ? "true" : "false";
	    int line = input_stream.getEndLine();
	    int column = input_stream.getEndColumn();
	    ByteArrayInputStream is2 = new ByteArrayInputStream(newText.getBytes());
	    Preprocessor.current.push(null);
        Preprocessor.files.push(Preprocessor.getFileName());
	    Preprocessor.preprocessing.push(input_stream);
		ReInit(new SimpleCharStream(is2, line, column));
    } : DEFAULT
}

<PREPROCESSOR_NDEFINED> SKIP: // parse define name
{
    "("
    {
        Preprocessor.level++;
        image.setLength(0);
    } : PREPROCESSOR_NDEFINED
|   " " : PREPROCESSOR_NDEFINED
|   < ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        defined = image.toString().trim();
        while (0 != Preprocessor.level) {
            Preprocessor.level--;
            if (RPAREN != getNextToken().kind)
                throw new AssertionError("Missing closing parenthesis after defined.");
        }
        // reinitialize input_stream
        newText = null != Preprocessor.defines(defined) ? "false" : "true";
        line = input_stream.getEndLine();
        column = input_stream.getEndColumn();
        is2 = new ByteArrayInputStream(newText.getBytes());
        Preprocessor.current.push(null);
        Preprocessor.files.push(Preprocessor.getFileName());
        Preprocessor.preprocessing.push(input_stream);
        ReInit(new SimpleCharStream(is2, line, column));
    } : DEFAULT
}

TOKEN : { /* Identifiers and numbers OR preprocessor defines */
	<IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* >
	{
        Preprocessor.DefineMapping current = Preprocessor.defines(image.toString());
        if (null != current) { // Identifier is defined in preprocessor
            Preprocessor.current.push(current);
	        Preprocessor.files.push(Preprocessor.getFileName());
            Preprocessor.preprocessing.push(input_stream);
            // parse arguments (or only parantheses for inline)
            if (current.size() > 0 || current.inline) {
                int level = 0;
                String text = ""; 
loop:           while (true) {
                    Token next = getNextToken();
                    text += next.image;
                    switch (next.kind) {
                    case LPAREN: level++; break;
                    case RPAREN: level--; if (0 == level) break loop;
                    }
                }
                text = text.substring(1, text.length()-1); // delete parentheses
		        String split[] = text.split(",");
		        if (text.length() != 0 && split.length != current.size()) 
		            throw new AssertionError("Mismatching "+ current.name +" --> '"+ current.defineText +"' with \""+ text +"\"");
		        int i = 0;
		        // bind arguments to parameters via preprocessor
		        if (current.size() > 0) // arguments need to be bound on a new scope
		        	Preprocessor.pushDefines();
		        for (String param : current.parameters) {
		            if (param.equals(split[i])) { // no rename required here
		                i++;
		                continue; // avoid inf. recursion
		            } 
		            Preprocessor.define.name = param;
		            Preprocessor.addDefine(split[i++], false);
		        }
            }
            // switch to a virtual stream and push the previous stream on a stack
		    ByteArrayInputStream is = new ByteArrayInputStream(current.defineText.getBytes());
		    ReInit(new SimpleCharStream(is, current.line, current.column));
            // override TOKEN result with next token after id (+ arguments).
            Token next = getNextToken(); 
            matchedToken.image = next.image;
            matchedToken.kind = next.kind;
            matchedToken.next = next.next;
            matchedToken.specialToken = next.specialToken;
        }
	}
|
	<NUMBER: (["0"-"9"])+ >
}

SKIP : { // Skip whitespace and comments
 	" "
|	"\r"
|	"\t"
|	"\n"
|	"/*" { Preprocessor.level++; } : IN_COMMENT
|   "//" : IN_COMMENT2
|   "#if" : PREPROCESSOR_IF
|   "#ifdef" : PREPROCESSOR_IFDEF
|   "#ifndef" : PREPROCESSOR_IFNDEF
|   "#else"
    {
        Boolean b = Preprocessor.ifs.peek();
        if (null == b) {
            throw new AssertionError("Spurious null in #if");
        } else if (true == b.booleanValue()) {
            SwitchTo(PREPROCESSOR_SKIP); // if was true, ignore else
        } else {
        	throw new AssertionError("Spurious false in DEFAULT else");
            //SwitchTo(DEFAULT); // if was false, parse else
        }
    }
|   "#elif"
    {
    	Preprocessor.ifs.peek();
        Boolean b3 = Preprocessor.ifs.peek();
        if (null == b3) {
            throw new AssertionError("Spurious null in DEFAULT #elif");
        } else if (true == b3.booleanValue()) {
            SwitchTo(PREPROCESSOR_SKIP); // if was true, ignore else
        } else {
        	throw new AssertionError("Unexpected false else in DEFAULT");
        }
    }
|   "#endif"
    {
        if (null == Preprocessor.ifs.pop()) { // pop last if
            throw new AssertionError("Spurious null in #if");
        } else {
            SwitchTo(DEFAULT); // end ITE
        }
    }
|   "#line" : PREPROCESSOR_FILE
|   "#file" : PREPROCESSOR_LINE
|	"#define" : PREPROCESSOR_DEFINE
|   "#include" : PREPROCESSOR_INCLUDE
|   "#"
}

/** Preprocessor if **/
<PREPROCESSOR_IF> SKIP:
{
    < "\n"|"\r"|"\r\n" > { // constant expression is read
        InputStream is = new ByteArrayInputStream(image.toString().getBytes());
        Preprocessor.preprocessing.push(null);
        Preprocessor.files.push(Preprocessor.getFileName());
        Promela prom = new Promela(parser, is); // start new parser for condition
        try {
            Expression expr = prom.expr();
            int num;
            try {
                num = expr.getConstantValue();
            } catch (Exception e) {
                throw new ParseException("The template expression '"+ expr +"' is not a constant");
            }
            if (0 != num) { // true
                Preprocessor.ifs.push(true);
                SwitchTo(DEFAULT); // parse if until else/endif
            } else { // false
                Preprocessor.ifs.push(false);
                SwitchTo(PREPROCESSOR_SKIP); // ignore if until else/enfi
            }
        } catch (Exception e) {
            throw new AssertionError("Failed to parse #if "+ image.toString()+ e);
        }
    }
}

<PREPROCESSOR_IF> MORE:
{
    "\\\n" {image = image.deleteCharAt(image.length()-2); } |
    "\\\r" {image = image.deleteCharAt(image.length()-2);} |
    "\\\r\n" {image = image.deleteCharAt(image.length()-3);} |
    < ~[] >
}

/** Preprocessor ifdef **/
<PREPROCESSOR_IFDEF> SKIP:
{
    < "\n"|"\r"|"\r\n" > { // define name is read
        String def = image.toString().trim();
        if (null != Preprocessor.defines(def)) { // true
            Preprocessor.ifs.push(true);
            SwitchTo(DEFAULT); // parse if until else/endif
        } else { // false
            Preprocessor.ifs.push(false);
            SwitchTo(PREPROCESSOR_SKIP); // ignore if until else/enfi
        }
    }
}

<PREPROCESSOR_IFDEF> MORE:
{
    < ~[] >
}

/** Preprocessor ifndef **/
<PREPROCESSOR_IFNDEF> SKIP:
{
    < "\n"|"\r"|"\r\n" > { // define name is read
        def = image.toString().trim();
        if (null == Preprocessor.defines(def)) { // true
            Preprocessor.ifs.push(true);
            SwitchTo(DEFAULT); // parse if until else/endif
        } else { // false
            Preprocessor.ifs.push(false);
            SwitchTo(PREPROCESSOR_SKIP); // ignore if until else/enfi
        }
    }
}

<PREPROCESSOR_IFNDEF> MORE:
{
    < ~[] >
}

<PREPROCESSOR_SKIP> SKIP:
{
	// push if (null = ignore complete ITE)
    < "#ifdef"|"#if" > { Preprocessor.ifs.push(null); } : PREPROCESSOR_SKIP
|   "#else"
    {
        Boolean b2 = Preprocessor.ifs.peek();
        if (null == b2) {
            SwitchTo(PREPROCESSOR_SKIP); // ignore else
        } else if (true == b2.booleanValue()) {
        	SwitchTo(PREPROCESSOR_SKIP); // (elif was true) ignore else
        } else {
            SwitchTo(DEFAULT);
        }
    }
|   "#elif" : PREPROCESSOR_ELIF_SKIP
|   "#endif"
    {
        if (null == Preprocessor.ifs.pop()) { // pop last if
            SwitchTo(PREPROCESSOR_SKIP); // keep ignoring input
        } else { // maybe false of true:
            SwitchTo(DEFAULT); // end ITE
        }
    }
|   < ~[] > : PREPROCESSOR_SKIP
}

/** Preprocessor if **/
<PREPROCESSOR_ELIF_SKIP> SKIP:
{
    < "\n"|"\r"|"\r\n" > { // constant expression is read
    	Boolean b1 = Preprocessor.ifs.peek();
        if (null == b1) { // bogus if
        	SwitchTo(PREPROCESSOR_SKIP);
        } else if (true == b1.booleanValue()) { // another if condition was true already
            SwitchTo(PREPROCESSOR_SKIP); // parse if until endif
        } else { // current if statement has thusfar not been true
	        Preprocessor.preprocessing.push(null);
        	InputStream is3 = new ByteArrayInputStream(image.toString().getBytes());
	        Promela prom2 = new Promela(parser, is3); // start new parser for condition
	        try {
	            Expression expr = prom2.expr();
                int num;
                try {
                    num = expr.getConstantValue();
                } catch (Exception e) {
                    throw new ParseException("The template expression '"+ expr +"' is not a constant");
                }
            	if (0 != num) { // true
        			Preprocessor.ifs.pop();
            	   	Preprocessor.ifs.push(true);
            	   	SwitchTo(DEFAULT); // parse elif until else/endif
            	} else { //false
            		SwitchTo(PREPROCESSOR_SKIP); // skip until elif/endif
            	}
	        } catch (Exception e) {
                int line1 = input_stream.getEndLine();
	            throw new AssertionError("Failed to parse #elif at "+ line1 +":"+ e);
	        }
        }
    }
}

<PREPROCESSOR_ELIF_SKIP> MORE:
{
    "\\\n" {image = image.deleteCharAt(image.length()-2); } |
    "\\\r" {image = image.deleteCharAt(image.length()-2);} |
    "\\\r\n" {image = image.deleteCharAt(image.length()-3);} |
    < ~[] >
}

<PREPROCESSOR_FILE> SKIP:
{
    < "\n"|"\r"|"\r\n" > {
        Preprocessor.file(input_stream, image.toString());
    } : DEFAULT
}

<PREPROCESSOR_FILE> MORE:
{
    "\\\n" |
    "\\\r" |
    "\\\r\n" |
    < ~[] >
}

<PREPROCESSOR_LINE> SKIP:
{
    < "\n"|"\r"|"\r\n" > {
        Preprocessor.line(input_stream, image.toString());
    } : DEFAULT
}
    
<PREPROCESSOR_LINE> MORE:
{
    "\\\n" |
    "\\\r" |
    "\\\r\n" |
    < ~[] >
}

/**
 * PREPROCESSOR IN-LEXER PARSING OF INLINE PARAMETERS
 * Could be moved to the parser with a new InlineAction class.
 *
 *              \s          \s          \s           \s            \s
 *              /-\         /-\         /-\          /-\     ID    /-\
 * 'inline'     v |   ID    v |   '('   v |    ID    v |    <--    v |
 * --------> |INLINE| --> |PARAM| --> |PARAM0| --> |PARAM2|     |PARAM1|
 *                                       |             |    -->
 *                                   ')'  \        ')' |    ','
 *                                         \           v
 *                                          \------> |TEXT| 
 */

<PREPROCESSOR_INLINE> SKIP:
{
    " "|"\t"|"\n"|"\r"|"\r\n" : PREPROCESSOR_INLINE
|   < ("_")* ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        Preprocessor.define.name = image.toString();
    } : PREPROCESSOR_INLINE_PARAM
}

<PREPROCESSOR_INLINE_PARAM> SKIP: // parse parameters
{
    " "|"\t"|"\n"|"\r"|"\r\n" : PREPROCESSOR_INLINE_PARAM
|   < "(" > : PREPROCESSOR_INLINE_PARAM0
|   < ~[] > { if (true){throw new AssertionError("Parsing of inline parameters failed for inline: "+ Preprocessor.define.name);} }
}

<PREPROCESSOR_INLINE_PARAM0> SKIP: // parse parameters
{
    " "|"\t"|"\n"|"\r"|"\r\n" : PREPROCESSOR_INLINE_PARAM0
|   <["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        Preprocessor.define.parameters.add(image.toString().trim());
    } : PREPROCESSOR_INLINE_PARAM2
|   < ")" > : PREPROCESSOR_INLINE_TEXT
|   < ~[] > { if (true){throw new AssertionError("Parsing of inline parameters failed for inline: "+ Preprocessor.define.name);} }
}

<PREPROCESSOR_INLINE_PARAM1> SKIP: // parse parameters
{
    " "|"\t"|"\n"|"\r"|"\r\n" : PREPROCESSOR_INLINE_PARAM1
|   <["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        Preprocessor.define.parameters.add(image.toString().trim());
    } : PREPROCESSOR_INLINE_PARAM2
|   < ~[] > { if (true){throw new AssertionError("Parsing of inline parameters failed for inline: "+ Preprocessor.define.name);} }
}

<PREPROCESSOR_INLINE_PARAM2> SKIP: // parse parameters
{
    " "|"\t"|"\n"|"\r"|"\r\n" : PREPROCESSOR_INLINE_PARAM2
|   < "," > : PREPROCESSOR_INLINE_PARAM1
|   < ")" > : PREPROCESSOR_INLINE_TEXT
|   < ~[] > { if (true){throw new AssertionError("Parsing of inline parameters failed for inline: "+ Preprocessor.define.name);} }
}

/**
 * END PREPROCESSOR IN-LEXER PARSING OF INLINE PARAMETERS
 */

<PREPROCESSOR_INLINE_TEXT> SKIP: // parse inline text
{
    < " "|"\t"|"\n"|"\r"|"\r\n" > : PREPROCESSOR_INLINE_TEXT
|   < "{" >
	{
	    if (Preprocessor.level != 0) throw new AssertionError("Unexpected");
	    Preprocessor.level++;
	    Preprocessor.define.line = input_stream.getEndLine();
	    Preprocessor.define.column = input_stream.getEndColumn();
	} : PREPROCESSOR_INLINE_REST
}

<PREPROCESSOR_INLINE_REST> MORE: // end parse inline text
{
    < "{" > { Preprocessor.level++; }
|   < "}" >
	{
        Preprocessor.level--;
        if (0 == Preprocessor.level) {
	        image.setLength(image.length() - 1); // remove '}'
	        // add inline to preprocessor defines
	        Preprocessor.addDefine(image.toString(), true);
            SwitchTo(DEFAULT);
        } else {
            SwitchTo(PREPROCESSOR_INLINE_REST);
        }
    }
|   < ~[] >
}

/**
 * PREPROCESSOR IN-LEXER PARSING OF DEFINE PARAMETERS
 */
 
<PREPROCESSOR_DEFINE> MORE: // parse define name
{
    < " "|"\t" > : PREPROCESSOR_DEFINE
|   <DEFINE: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        Preprocessor.backup(input_stream, image);
    } : PREPROCESSOR_DEFINE_PARAM
}

<PREPROCESSOR_DEFINE_PARAM> MORE: // parse define parameters
{
    < " "|"\t" > : PREPROCESSOR_DEFINE_PARAM
|   < "(" > {
        Preprocessor.define.length += image.length();
        image.setLength(0);
    } : PREPROCESSOR_DEFINE_PARAM1
|   < ~[] > { // parsing failed, restore input_stream to initial state
        Preprocessor.restore(input_stream, image);
     } : PREPROCESSOR_DEFINE_REST
}

<PREPROCESSOR_DEFINE_PARAM1> MORE: // parse define parameters
{
    < " "|"\t" > : PREPROCESSOR_DEFINE_PARAM1
|   <PARAM: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z"] | ["0"-"9"] | "_")* > {
        Preprocessor.define.parameters.add(image.toString().trim());
        Preprocessor.define.length += image.length();
        image.setLength(0);
    } : PREPROCESSOR_DEFINE_PARAM2
|   < ~[] > { // parsing failed, restore input_stream to initial state
        Preprocessor.restore(input_stream, image);
     } : PREPROCESSOR_DEFINE_REST
}

<PREPROCESSOR_DEFINE_PARAM2> MORE: // parse define parameters
{
    < " "|"\t" > : PREPROCESSOR_DEFINE_PARAM2
|   < "," > {
        Preprocessor.define.length += image.length();
        image.setLength(0);
    } : PREPROCESSOR_DEFINE_PARAM1
|   < ")" > {
        image.setLength(0);
    } : PREPROCESSOR_DEFINE_REST
|   < ~[] > { // parsing failed, restore input_stream to initial state
        Preprocessor.restore(input_stream, image);
     } : PREPROCESSOR_DEFINE_REST
}

/**
 * END PREPROCESSOR IN-LEXER PARSING OF DEFINE PARAMETERS
 */

<PREPROCESSOR_DEFINE_REST> SKIP: // end parse define text
{
    < "\n"|"\r"|"\r\n" > { // add define text (and parameters) to preprocessor        // unlike inlines, defines have not necessarily empty parentheses
        String define = image.toString();
        boolean inline = define.startsWith("()");
        if (inline) define = define.substring(2);
        Preprocessor.addDefine(define, inline);
	} : DEFAULT
}
    
<PREPROCESSOR_DEFINE_REST> MORE: // parse define text
{
    "\\\n" {image = image.deleteCharAt(image.length()-2); } |
    "\\\r" {image = image.deleteCharAt(image.length()-2);} |
    "\\\r\n" {image = image.deleteCharAt(image.length()-3);} |
    < ~[] >
}

<PREPROCESSOR_INCLUDE> MORE:
{    < " "|"\t" > : PREPROCESSOR_INCLUDE
|   < "\"" > : PREPROCESSOR_INCLUDE_FILE
}

<PREPROCESSOR_INCLUDE_FILE> SKIP: // launch virtual input stream for include
{
    < "\"" > {
        String file = Preprocessor.parseFile(image.toString());
        // create new virtual input stream and push the previous one to a stack
        Preprocessor.preprocessing.push(input_stream);
        Preprocessor.current.push(null);
        Preprocessor.files.push(Preprocessor.getFileName());
        Preprocessor.setFilename(image.toString().trim().replaceAll("^\"|\"$", ""));
        try { // switch input stream
            ReInit(new SimpleCharStream(new FileInputStream(file)));
        } catch (FileNotFoundException fne) { throw new AssertionError(fne); }
        if (matchedToken == null) return;
        // override TOKEN result with next token after id (+ arguments).
        Token next = getNextToken();
        matchedToken.image = next.image;
        matchedToken.kind = next.kind;
        matchedToken.next = next.next;
        matchedToken.specialToken = next.specialToken;
    } : DEFAULT
}

<PREPROCESSOR_INCLUDE_FILE> MORE:
{
    < ~["\""] >
}

<IN_COMMENT2> SKIP: {
    < ~["\n","\r"] >
}

<IN_COMMENT2> SKIP: {
    < "\n"|"\r"|"\r\n" >: DEFAULT
}

<IN_COMMENT> SKIP: {
	"/*" { Preprocessor.level++; }
|	< ~[] >
}

<IN_COMMENT> SKIP: {
	"*/" {
		Preprocessor.level--;
		if (0 == Preprocessor.level) {
			SwitchTo(DEFAULT);
		} else {
			SwitchTo(IN_COMMENT);
		}
	}
}

MORE : { // The string
	"\"": IN_STRING
}

<IN_STRING> MORE: {
	< ~["\""] >
}

<IN_STRING> TOKEN: {
	<STRING: "\"">: DEFAULT
}

/* The specification itself */
Specification spec(String name): {
	specification = new Specification(name);
}{	
	(module()) *
	{ return specification; }
}

/* Each part in the specification is a called a module */
void module(): {
}{
    LOOKAHEAD(2) proctype()
|	one_decl(specification.getVariableStore(), null, false)
|	init()
|	never()
|	<SEMICOLON>
}

/*** Here the different modules are defined ***/

/* Definition of a process */
void proctype(): {
	int nrActive = 0;
	Token n, id, b;
	State s;
	Expression e;
}{
	(id=<IDENTIFIER> 
	  {
	       if (!id.image.equals("active"))
	           throw new ParseException("Expected 'active' at line " + id.beginLine +", column "+ id.beginColumn);
	       nrActive = 1;
	  }
	  (b=<LBRACK> e=expr()
	       {
	           try {                   nrActive = e.getConstantValue();
	           } catch (Exception pe) {
	               throw new MyParseException("Proc requires a constant number of instances, not: "+ e, b);	           }
	       }
	  <RBRACK>)?
	)?
	<PROCTYPE>
	id=<IDENTIFIER>
	{
		currentProc = new Proctype(specification, getNextProcNr(nrActive), nrActive, id.image);
		automaton = currentProc.getAutomaton();
		specification.addProc(currentProc);
        addPC(currentProc);
        addPID(currentProc);
        declarations = true;
	}
	<LPAREN> (decl_list(currentProc))? <RPAREN>
	{
		currentProc.lastArgument();
	}
	(priority())?
	(enabler())?
	<LCURLY> s=sequence(currentProc.getStartState(), null, false) <RCURLY>
	{
		if(s != null) {
			new EndTransition(s);
		}
		setGotos();
		currentProc = null;
	}
}

void priority(): {
	ConstantExpression c;
}{
	<PRIORITY> c=constant()
	{ currentProc.setPriority(c.getNumber()); }
}

void enabler(): {
	Expression expr;
}{
	<PROVIDED> <LPAREN> expr=expr() <RPAREN>
	{ currentProc.setEnabler(expr); }
}

/* An init process */
void init(): {
	State s;
}{
	<INIT>
	{
		currentProc = new Proctype(specification, getNextProcNr(1), 1, "init");
		automaton = currentProc.getAutomaton();
		specification.addProc(currentProc);
		currentProc.lastArgument();
        addPC(currentProc);
		addPID(currentProc);
		declarations = true;
	}
	(priority())?
	<LCURLY> s=sequence(currentProc.getStartState(), null, false) <RCURLY>
	{
		if(s != null) {
			new EndTransition(s);
		}
		setGotos();
		currentProc = null;
	}
}

void never(): {
	State s;
}{
	<NEVER>
	{
		currentProc = new Proctype(specification, -1, 0, "never"); // a never claim has no PID
		automaton = currentProc.getAutomaton();
		specification.setNever(currentProc);
		currentProc.lastArgument();
		addPC(currentProc);
		declarations = true;
	}
	<LCURLY> s=sequence(currentProc.getStartState(), null, false) <RCURLY>
	{
		if(s != null) {
			new EndTransition(s);
		}
		setGotos();
		currentProc = null;
	}
}

/*** Here the declarations start ***/

void decl_list(VariableContainer store): {
}{
	one_decl(store, null, false)
	   (LOOKAHEAD(<SEMICOLON> one_decl())
	              <SEMICOLON> one_decl(store, null, false) )*
}


State one_decl(VariableContainer store, State start, boolean inAtomic): {
    boolean hidden = false;
    State end = start;
}{
(<HIDDEN> { hidden = true; })? (<SHOW>)?
(
    <TYPEDEF> utype(hidden) (<COMMA> utype(hidden))*
|   LOOKAHEAD(3) <MTYPE> mtype(hidden) (<COMMA> mtype(hidden))*
|	type=typename()
    (LOOKAHEAD( {type instanceof ChannelType} )
	   ivar_chan(store, hidden) (<COMMA> ivar_chan(store, hidden))*
	|  end = ivar(store, type, hidden, end, inAtomic)
	   (<COMMA>  end = ivar(store, type, hidden, end, inAtomic))*
	)
)
{ return end; }
}

void utype(boolean hidden): {
    Token id;
}{
    id=<IDENTIFIER> 
    { CustomVariableType custom = specification.newCustomType(id.image); if (hidden) throw new MyParseException("Cannot declare a custom variable type as hidden ", id); }
    <LCURLY>
       decl_list(custom.getVariableStore()) (<SEMICOLON>)?
    <RCURLY>
}

void mtype(boolean hidden): {
    Token id, ref = null;
}{
    (<ASSIGN>)? <LCURLY> id=<IDENTIFIER>
       { specification.addMType(id.image); if (hidden) throw new MyParseException("Cannot declare an mtype as hidden ", id); }
    (LOOKAHEAD(2) <COMMA> id=<IDENTIFIER>
       { specification.addMType(id.image); }
    )* (<COMMA>)? <RCURLY>
}

State ivar(VariableContainer store, VariableType type, boolean hidden,
          State start, boolean inAtomic): {
	Token id, assign;
	State end = start;
	int arraySize = -1;
	Expression expr = null;
	ConstantExpression c = null;
}{
	id=<IDENTIFIER> 
	(<LBRACK> c=constant() <RBRACK> { arraySize = c.getNumber(); })? 
	{ Variable var = new Variable(type, id.image, arraySize,currentProc); var.setHidden(hidden); }
	(assign=<ASSIGN> 
	   expr=lor_expr()
	   {
	       if (declarations || start == null) {
	           var.setInitExpr(expr);
	       } else {
               end = new State(automaton, inAtomic);
               Identifier ident = new Identifier(id, var, null);               start.newTransition(new AssignAction(assign, ident, expr), end);
	       }
	   }
	)?
	{
	    if (store.getVariable(id.image) == null) {	       store.addVariable(var);
	    } else { // could happen with inlines:	       String inProc = currentProc == null ? "" : " detected in "+ currentProc.getName();
	       System.out.println("Warning: duplicate variable '"+ id.image +"'"+ inProc);
        }
        return end;
	}
}

void ivar_chan(VariableContainer store, boolean hidden): {
	Token id, as;	
	int arraySize = -1;
	ConstantExpression c = null;
	ChannelVariable var;
}{
	id=<IDENTIFIER>
	(<LBRACK> c=constant() <RBRACK> { arraySize = c.getNumber(); })? 
	{
		var = new ChannelVariable(id.image, arraySize, currentProc);
		var.setHidden(hidden);
		var.setOwner(currentProc);
		if (null != currentProc && currentProc.isArgument()) {
			store.addVariable(var); // proc arguments can be uninitialized channels
		}
	}
	(as=<ASSIGN> ch_init(as, store, var))?
}

void ch_init(Token as, VariableContainer store, ChannelVariable var): {
	Expression size;
	VariableType type;
	ChannelType ctype;
	Token id;
	if (null != currentProc && currentProc.isArgument()) {
		throw new MyParseException("Illegal assignment to proc arguments.", as);
	}
}{
    id=<IDENTIFIER>
    {
		var.setInitExpr(new Identifier(store.getVariable(id.image)));
		store.addVariable(var);    }
  |
	<LBRACK> size=constant() <RBRACK> <OF> 
	{
       try {
            ctype = new ChannelType(size.getConstantValue());
        } catch (Exception e) {
            throw new ParseException("The channel size expression '"+ size +"' is not a constant");
        }
		var.setType(ctype); 
	}
	<LCURLY> type=typename() 
	{ ctype.addType(type); }
	(<COMMA> type=typename()
	{ ctype.addType(type); }
	)* <RCURLY>
	{ store.addVariable(var); }
}

VariableType typename(): {
	Token t;
}{
	<BIT> { return VariableType.BIT; }
|	<BOOL> { return VariableType.BOOL; }
|	<BYTE> { return VariableType.BYTE; }
|	<PID> { return VariableType.PID; }
|	<SHORT> { return VariableType.SHORT; }
|	<INT> { return VariableType.INT; }
|	<MTYPE> { return VariableType.MTYPE; }
|	<CHAN> { return ChannelType.UNASSIGNED_CHANNEL; }
|	t=<IDENTIFIER> {
        return specification.getCustomType(t.image.trim());
	}
}

/*** Here all the normal statements are defined ***/

State sequence(State start, State breakNode, boolean inAtomic): {
	Expression expr;
	Token id, t;
	State end = start;
	State start1, end1;
	Transition trans;
}{
(   delim() (end=sequence(end, breakNode, inAtomic))?
| LOOKAHEAD(one_decl())
(
	end = one_decl(currentProc, start, inAtomic)
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
)
|  { declarations = false; } // the first declarations are assumed to be constant
(
 	<XR> expr=varref()
	{ currentProc.addXR((Identifier)expr); } 
	(<COMMA> expr=varref() { currentProc.addXR((Identifier)expr); })*
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	<XS> expr=varref()
	{ currentProc.addXS((Identifier)expr); } 
	(<COMMA> expr=varref() { currentProc.addXS((Identifier)expr); })*
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |  <FOR> {
        ConstantExpression b, e;
    }
    <LPAREN> expr=varref() <COLON> b=onlyconstant() <DOT><DOT> e=onlyconstant() <RPAREN>
    {
        end = new State(automaton, inAtomic);
        start.newTransition(LTSminUtil.assign((Identifier)expr, b), end);
        start1 = end;
    }
    <LCURLY> end=sequence(end, breakNode, inAtomic) <RCURLY>
    {
        trans = end.newTransition(new ExprAction(compare(LT, expr, e)), start1);
        trans.addAction( incr((Identifier)expr) );

        end1 = end;
        end = new State(automaton, inAtomic);
        end1.newTransition(new ExprAction(compare(GTE, expr, e)), end);
    }
    (end=sequence(end, breakNode, inAtomic))?
 |	<IF> 
	{ end = new State(automaton, inAtomic); }
	(option(start, end, breakNode, inAtomic))+
	<FI>
	(end=sequence(end, breakNode, inAtomic))?
 |	<DO> 
	{ end = new State(automaton, inAtomic); }
	(option(start, start, end, inAtomic))+
	<OD>
	(end=sequence(end, breakNode, inAtomic))?
 |	LOOKAHEAD(<IDENTIFIER> <COLON>)
	id=<IDENTIFIER> <COLON>
	{
        String label = id.image +"_"+ Preprocessor.getLevel();
		if(labels.containsKey(label)) {
			throw new MyParseException("Duplicate label: "+ id.image, id);
		}
		labels.put(label, start);
		start.addLabel(label);
	}
	(end=sequence(end, breakNode, inAtomic))?
 |	LOOKAHEAD(channel_statement())
	end=channel_statement(start, breakNode, inAtomic)
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	LOOKAHEAD(assign())
	end=assign(start, breakNode, inAtomic)
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	expr=expr()
	{
		end = new State(automaton, inAtomic);
		start.newTransition(new ExprAction(expr), end);
	}
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	t=<ELSE>
	{
		end = new State(automaton, inAtomic);
		//start.newTransition(new ElseAction(t), end);
		new ElseTransition(start, end);
	}
	(end=sequence(end, breakNode, inAtomic))?
 |	t=<GOTO> id=<IDENTIFIER>
	{
        String label = id.image +"_"+ Preprocessor.getLevel();
        Token tok = new Token(IDENTIFIER, label);
        tok.beginLine = id.beginLine;
        tok.endLine = id.endLine;
        tok.beginColumn = id.beginColumn;
        tok.endColumn = id.endColumn;
		gotos.put(start, tok);
		end = new State(automaton, inAtomic);
	}
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	t=<PRINT> <LPAREN> id=<STRING>
	{ PrintAction pa = new PrintAction(t, id.image); }
	(<COMMA> arg_lst(pa))? <RPAREN>
	{	
		end = new State(automaton, inAtomic);
		start.newTransition(pa, end);
	}
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	t=<ASSERT> expr=expr()
	{
		end = new State(automaton, inAtomic);
		start.newTransition(new AssertAction(t, expr), end);
	}
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	t=<BREAK>
	{
		if(breakNode == null) {
			throw new MyParseException("Breakstatement found without a do-loop to break out of!", t);
		}
		new GotoTransition(start, breakNode, "break");
		end = new State(automaton, inAtomic);
	}
	(delim() (end=sequence(end, breakNode, inAtomic))?)?
 |	t=<ATOMIC>
	{
		end = new State(automaton, true);
		new UselessTransition(start, end, "ATOMIC");
	}
	<LCURLY> end=sequence(end, breakNode, true) <RCURLY>
	{ 
		end.setInAtomic(false);
	}
	(end=sequence(end, breakNode, inAtomic))?
|   t=<D_STEP>
	{ 
		end = new State(automaton, inAtomic);
		trans = start.newTransition(end); 
	}
	<LCURLY> dstep_sequence(trans, null) <RCURLY>
	(end=sequence(end, breakNode, inAtomic))?
 |	<LCURLY> end=sequence(start, breakNode, inAtomic) <RCURLY>
	(end=sequence(end, breakNode, inAtomic))?
))
(
    LOOKAHEAD(<UNLESS> sequence())    <UNLESS>
    {
        start1 = new State(automaton, inAtomic);
    }
    end1=sequence(start1, breakNode, inAtomic)
    {
        for (Transition tr : end1.input) {
            tr.changeTo(end);
        }
        end1.delete();
        automaton.addUnless(start, end, start1, unlessPriority++);    }
)?
	{ return end; }
}

void delim(): {}{
	<SEMICOLON> | <RARROW>
}

void option(State start, State end, State breakNode, boolean inAtomic): {
	State tempEnd;
}{
	<OPTION>
	{ 
		State s = new State(automaton, inAtomic);
		new UselessTransition(start, s, "OPTION"); 
	}
	tempEnd=sequence(s, breakNode, inAtomic)
	{ if(tempEnd != null) end.merge(tempEnd); }
}

State channel_statement(State start, State breakNode, boolean inAtomic): {
	Expression expr;
	Token t;
	State end = new State(automaton, inAtomic);
}{
	expr=varref()
	( t=<LNOT>
	  {
	  	ChannelSendAction send = new ChannelSendAction(t, (Identifier)expr);
		start.newTransition(send, end);
	  }
	  send_args(send)
	| t=<CH_SEND_SORTED>
      {
        ChannelSendAction send2 = new ChannelSendAction(t, (Identifier)expr, true);
        start.newTransition(send2, end);
      }
      send_args(send2)
	| t=<CH_READ>
	  ( {
	  	  ChannelReadAction read = new ChannelReadAction(t, (Identifier)expr, false, false);
	  	  start.newTransition(read, end);
	    }
	    recv_args(read)
	  | {
	  	  ChannelReadAction read2 = new ChannelReadAction(t, (Identifier)expr, true, false);
          start.newTransition(read2, end);
	    }
	    <LT> recv_args(read2) <GT>
	  )
	| t=<CH_READ_RAND>
	  (
      {
          ChannelReadAction read3 = new ChannelReadAction(t, (Identifier)expr, false, true);
          start.newTransition(read3, end);
      }
      recv_args(read3)
	  | 
      {
          ChannelReadAction read4 = new ChannelReadAction(t, (Identifier)expr, true, true);
          start.newTransition(read4, end);
      }
	  <LT> recv_args(read4) <GT>
	  )
	)
	{ return end; }
}

State assign(State start, State breakNode, boolean inAtomic): {
	Identifier id;
	Expression expr;
	Token t;
	State end = new State(automaton, inAtomic);
}{
	expr=varref()
	{
		try {
			id = (Identifier)expr;
		} catch(ClassCastException ex) {
			throw new MyParseException("Not a valid identifier on the left side of the assignment", expr.getToken());
		}
	}
	  ( t=<ASSIGN> expr=lor_expr()
	  { start.newTransition(new AssignAction(t, id, expr), end); }
	  | t=<INCR>
	  { start.newTransition(new AssignAction(t, id), end); }
	  | t=<DECR>
	  { start.newTransition(new AssignAction(t, id), end); }
	  )
	{ return end; }
}

/*** Special dstep statement parsing ***/

void dstep_sequence(ActionContainer cont, OptionAction loop): {
	Token t, id;
	Expression expr;
	OptionAction opt;
}{
	delim() (dstep_sequence(cont, loop))?
|	LOOKAHEAD(one_decl())
	{ throw new ParseException("Variables can not be declared inside a d_step"); }
	one_decl(null, null, false) delim()
|	(t=<XR> | t=<XS>) expr=varref()
	{ throw new MyParseException("Can not declare exclusive reads or writes in a d_step", t); } 
	(<COMMA> expr=varref())*
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<IF> 
	{ opt = new OptionAction(t, false); cont.addAction(opt); }
	(dstep_option(opt, loop))+
	<FI>
	(dstep_sequence(cont, loop))?
|	t=<DO>
	{ opt = new OptionAction(t, true); cont.addAction(opt); }
	(dstep_option(opt, opt))+
	<OD>
	( dstep_sequence(cont, loop) { opt.hasSuccessor(true); } )?
|	LOOKAHEAD(<IDENTIFIER> <COLON>)
	id=<IDENTIFIER> <COLON>
    { cont.addAction(new LabelAction(id, id.image)); }
    dstep_sequence(cont, loop)
|	LOOKAHEAD(dstep_channel_statement())
	dstep_channel_statement(cont)
	(delim() (dstep_sequence(cont, loop))?)?
|	LOOKAHEAD(dstep_assign())
	dstep_assign(cont)
	(delim() (dstep_sequence(cont, loop))?)?
|	expr=expr()
	{ cont.addAction(new ExprAction(expr)); }
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<ELSE>
	{ cont.addAction(new ElseAction(t)); }
	(dstep_sequence(cont, loop))?
|	t=<GOTO> id=<IDENTIFIER>
    { cont.addAction(new GotoAction(t, id.image)); }
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<PRINT> <LPAREN> id=<STRING>
	{ PrintAction pa = new PrintAction(t, id.image); }
	(<COMMA> arg_lst(pa))? <RPAREN>
	{ cont.addAction(pa); }
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<ASSERT> expr=expr()
	{ cont.addAction(new AssertAction(t, expr)); }
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<BREAK>
	{
        if(loop == null)
            throw new MyParseException("Breakstatement found without a do-loop to break out of!", t);
        cont.addAction(new BreakAction(t, loop));
    }
	(delim() (dstep_sequence(cont, loop))?)?
|	t=<ATOMIC> // is ignored
	<LCURLY> dstep_sequence(cont, loop) <RCURLY>
	(dstep_sequence(cont, loop))?
|	t=<D_STEP> // is ignored
	<LCURLY> dstep_sequence(cont, loop) <RCURLY>
	(dstep_sequence(cont, loop))?
|	<LCURLY> dstep_sequence(cont, loop) <RCURLY>
	(dstep_sequence(cont, loop))?
}

void dstep_option(OptionAction opt, OptionAction loop): {
	Sequence seq;
}{
	<OPTION>
	{ seq = opt.startNewOption(); }
	dstep_sequence(seq, loop)
}

void dstep_channel_statement(ActionContainer cont): {
	Token t;
    Expression expr;
}{
    expr=varref()
    ( t=<LNOT> 
      {
        ChannelSendAction send = new ChannelSendAction(t, (Identifier)expr);
        cont.addAction(send);
      }
      send_args(send)
    | t=<CH_SEND_SORTED> 
      { throw new MyParseException("Sorted send is not yet supported!", t); }
      send_args(null)
    | t=<CH_READ>
      ( {
          ChannelReadAction read = new ChannelReadAction(t, (Identifier)expr);
          cont.addAction(read);
        }
        recv_args(read)
      | {
          ChannelReadAction read2 = new ChannelReadAction(t, (Identifier)expr, true, false);
          cont.addAction(read2);
        }
        <LT> recv_args(read2) <GT>
      )
    | t=<CH_READ_RAND>
      (
      {
          ChannelReadAction read3 = new ChannelReadAction(t, (Identifier)expr, false, true);
          cont.addAction(read3);
      }
      recv_args(read3)
      | 
      {
          ChannelReadAction read4 = new ChannelReadAction(t, (Identifier)expr, false, true);
          cont.addAction(read4);
      }
      <LT> recv_args(null) <GT>
      )
    )
}

void dstep_assign(ActionContainer cont): {
	Identifier id;
	Expression expr;
	Token t;
}{
	expr=varref()
	{
		try {
			id = (Identifier)expr;
		} catch(ClassCastException ex) {
			throw new MyParseException("Not a valid identifier on the left side of the assignment", expr.getToken());
		}
	}
	  ( t=<ASSIGN> expr=lor_expr()
	  {	cont.addAction(new AssignAction(t, id, expr)); }
	  | t=<INCR>
	  {	cont.addAction(new AssignAction(t, id, null)); }
	  | t=<DECR>
	  {	cont.addAction(new AssignAction(t, id, null)); }
	  )
}

/*** Arguments parsing ***/

void send_args(CompoundExpression c): {
	Expression expr;
}{
	LOOKAHEAD(lor_expr() <LPAREN>) 
	expr=lor_expr() 
	{ c.addExpression(expr); }
	<LPAREN> arg_lst(c) <RPAREN>
|	arg_lst(c)
}

void recv_args(CompoundExpression c): {
}{
	recv_arg(c) (<COMMA> recv_args(c) | <LPAREN> recv_args(c) <RPAREN>)?
| 	<LPAREN> recv_args(c) <RPAREN>
}

void recv_arg(CompoundExpression c): {
	Token t;
	Expression expr;
}{
	expr=varref()
	{ c.addExpression(expr); }
|	t=<EVAL> <LPAREN> expr=varref() <RPAREN>
	{ c.addExpression(new EvalExpression(t, expr)); }
|	expr=onlyconstant()
	{ c.addExpression(expr); }
}

void arg_lst(CompoundExpression expr): {
	Expression ex1;
}{
	(ex1=lor_expr()
	{ expr.addExpression(ex1); }
	(<COMMA> ex1=lor_expr()
	{ expr.addExpression(ex1); }
	)*
	)?
}

/*** All expression statements ***/

Expression varref(Identifier context): {
	Token id, proc, dot = null;
	Expression expr = null;
	Expression expr2 = null;
	Identifier ident;
	Variable var = null;
}{
    LOOKAHEAD( { getToken(1).kind == IDENTIFIER &&
                 specification.getProcess(getToken(1).image) != null } )
    proc=<IDENTIFIER>
    (<LBRACK> expr=lor_expr() <RBRACK>)?
    dot=<COLON>
    {
        if (currentProc != specification.getNever())
            throw new MyParseException("Remote variable references only allowed in never claim", dot);        Proctype old = currentProc;
        currentProc = specification.getProcess(proc.image);
        Expression ex = varref(null);
        currentProc = old;
        
        if (ex instanceof Identifier) {           ident = (Identifier) ex;
           int index = 0;
           if (expr != null) {               try {                 index = expr.getConstantValue();
               } catch (Exception e) {                    throw new MyParseException("Only constants supported in remote variable references", dot);
               }
           }
           ident.setInstanceIndex(index);
        }        return ex;
    }
| 	id=<IDENTIFIER>
	{
		int mtypeNr = specification.getMType(id.image);
		if(mtypeNr > 0) {
			return new MTypeReference(id, mtypeNr);
		}
	}
	(<LBRACK> expr=lor_expr() <RBRACK>)?
	{
		if (null == context) {
			if (currentProc != null) {
                var = currentProc.getVariable(id.image);
			}
			if (var == null) {
				var = specification.getVariableStore().getVariable(id.image);
			}
			if (var == null) {
	           throw new MyParseException("Undeclared identifier: " + id.image, id);
	        }
	        ident = new Identifier(id, var, expr, null);
	    } else {
	       CustomVariableType cvt;
            try {
                cvt = (CustomVariableType)context.getVariable().getType();
            } catch (ClassCastException cce) {
                throw new MyParseException("Variable is not a struct " + context, context.getToken());
            }
            var = cvt.getVariableStore().getVariable(id.image);
            if (var == null) {
                throw new MyParseException("Struct "+ cvt +" has no member " + id.image, id);
            }
            ident = new Identifier(id, var, expr, null);
	    }
        if ((null == expr) != (-1 == ident.getVariable().getArraySize())) {
            throw new MyParseException("Invalid array semantics in expression: "+ id, id);
        }
    }
    (dot=<DOT> expr2=varref(ident) {
	        if (!(expr2 instanceof Identifier))
	            throw new MyParseException("Not an identifier: " + expr2, dot);
		    ident.setSub((Identifier)expr2);
		})?
	{ return ident; }
|	id=<VAR_PID>
	{ return new Identifier(id, currentProc.getVariable(id.image), null, null); }
|   id=<VAR_NR_PR>
    { return new Identifier(id, specification.getVariableStore().getVariable(id.image), null, null); }
}

Expression base_expr(): {
	Expression ex1 = null, ex2, ex3;
	Token t, id, id2;
}{
	LOOKAHEAD(<LPAREN> lor_expr() <RARROW>) 
	<LPAREN> ex1=lor_expr() t=<RARROW> ex2=lor_expr() <COLON> ex3=lor_expr() <RPAREN>
	{ return new AritmicExpression(t, ex1, ex2, ex3); }
|	<LPAREN> ex1=expr() <RPAREN>
	{ return ex1; }
|	t=<LEN> <LPAREN> ex1=varref() <RPAREN>
	{ return new ChannelLengthExpression(t, ex1); }
|	LOOKAHEAD(<IDENTIFIER> (<LBRACK> lor_expr() <RBRACK>)? <AT> <IDENTIFIER>)
	id=<IDENTIFIER> (<LBRACK> ex1=lor_expr() <RBRACK>)? <AT> id2=<IDENTIFIER>
	{ return new RemoteRef(id, id2, ex1); }
|	ex1=varref()
	  ( t=<CH_READ>
           {
               ChannelReadExpression read = new ChannelReadExpression(t, (Identifier)ex1, false);
           }
           <LBRACK> recv_args(read) <RBRACK>
           { return read; }
	  | t=<CH_READ_RAND> 
           {
               ChannelReadExpression read2 = new ChannelReadExpression(t, (Identifier)ex1, true);
           }
	  <LBRACK> recv_args(read2) <RBRACK>
           { return read2; }
	  )?
	{ return ex1; }
|	ex1=onlyconstant()
	{ return ex1; }
|	t=<TIMEOUT>
	{ return new TimeoutExpression(t); }
|	t=<NP_>
	{ throw new MyParseException("np_ expressions are not yet supported!", t); }
|	t=<ENABLED> <LPAREN> lor_expr() <RPAREN>
	{ throw new MyParseException("enabled expressions are not yet supported!", t); }
|	t=<PC_VALUE> <LPAREN> lor_expr() <RPAREN>
	{ throw new MyParseException("pc_value expressions are not yet supported!", t); }
|	t=<RUN> id=<IDENTIFIER> 
	{ RunExpression runExpr = new RunExpression(t, id.image); }
	<LPAREN> arg_lst(runExpr) <RPAREN>
	{ return runExpr; }
|	t=chanop() <LPAREN> ex1=varref() <RPAREN>
	{ return new ChannelOperation(t, ex1); }
}

Expression unary_expr(): {
	Expression ex1;
	Token t;
}{
	(t=<BNOT> | t=<MINUS>) ex1=unary_expr()
	{ return new AritmicExpression(t, ex1); }
|	t=<LNOT> ex1=unary_expr()
	{ return new BooleanExpression(t, ex1); }
|	ex1=base_expr()
	{ return ex1; }
}

Expression mul_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=unary_expr()
	  ((t=<TIMES> | t=<DIVIDE> | t=<MODULO>) ex2=unary_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression add_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=mul_expr()
	  ((t=<PLUS> | t=<MINUS>) ex2=mul_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }	  
	  )*
	{ return ex1; }
}

Expression shift_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=add_expr()
	  ((t=<LSHIFT> | t=<RSHIFT>) ex2=add_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression cmp_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=shift_expr()
	  ((t=<LT> | t=<GT> | t=<LTE> | t=<GTE>) ex2=shift_expr()
	  { ex1 = new CompareExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression eq_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=cmp_expr()
	  ((t=<EQ> | t=<NEQ>) ex2=cmp_expr()
	  { ex1 = new CompareExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression and_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=eq_expr() 
	  (t=<BAND> ex2=eq_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }	
	  )*
	{ return ex1; }
}

Expression xor_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=and_expr() 
	  (t=<XOR> ex2=and_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }	
	  )*
	{ return ex1; }
}

Expression or_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=xor_expr() 
	  (t=<BOR> ex2=xor_expr()
	  { ex1 = new AritmicExpression(t, ex1, ex2); }	
	  )*
	{ return ex1; }
}

Expression land_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=or_expr() 
	  (t=<LAND> ex2=or_expr()
	  { ex1 = new BooleanExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression lor_expr(): {
	Expression ex1, ex2;
	Token t;
}{
	ex1=land_expr() 
	  (t=<LOR> ex2=land_expr()
	  { ex1 = new BooleanExpression(t, ex1, ex2); }
	  )*
	{ return ex1; }
}

Expression expr(): {
	Expression ex1;
}{
	ex1=lor_expr()
	{ return ex1; }
}

Token chanop(): {
	Token t;
}{
	(t=<FULL> | t=<NFULL> | t=<EMPTY> | t=<NEMPTY>)
	{ return t; }
}

ConstantExpression onlyconstant(): {
    Token n;
}{
    n=<TRUE>
    { return new ConstantExpression(n, 1); }
|   n=<FALSE>
    { return new ConstantExpression(n, 0); }
|   n=<SKIP_>
    { return new ConstantExpression(n, 1); }
|   n=<NUMBER>
    { return new ConstantExpression(n, Integer.parseInt(n.image)); }
}

ConstantExpression constant(): {
	Token n;
	ConstantExpression ex1;
}{
    ex1 = onlyconstant()
    { return ex1; }
|   n=<IDENTIFIER>
    {
        int mtypeNr = specification.getMType(n.image);
        if(mtypeNr > 0)
            return new MTypeReference(n, mtypeNr);
        throw new MyParseException("Expected constant!", n);
    }
}